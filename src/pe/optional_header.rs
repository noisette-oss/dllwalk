use nom::{
    bytes::complete::take,
    multi::count,
    number::complete::{le_u16, le_u32},
    sequence::tuple,
};

use super::{Architecture, FileParseResult};

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct DataDirectory {
    pub rva: u32,
    pub size: u32,
}

#[derive(Debug, PartialEq, Eq)]
pub struct OptionalHeader {
    architecture: Architecture,
    data_directories: Vec<DataDirectory>,
}

impl OptionalHeader {
    pub fn parse(input: &[u8]) -> FileParseResult<Self> {
        let (input, magic) = le_u16(input)?;

        let architecture = match magic {
            0x010b => Ok(Architecture::X86),
            0x020b => Ok(Architecture::X64),
            _ => panic!("magic {}", magic),
        }?;

        let (input, (_, number_of_rva_and_sizes)) = tuple((
            take(if architecture == Architecture::X86 {
                90_usize
            } else {
                106_usize
            }),
            le_u32,
        ))(input)?;

        // Data directories
        let (input, data_directories) =
            count(tuple((le_u32, le_u32)), number_of_rva_and_sizes as usize)(input)?;

        let data_directories = data_directories
            .iter()
            .map(|pair| DataDirectory {
                rva: pair.0,
                size: pair.1,
            })
            .collect();

        Ok((
            input,
            OptionalHeader {
                architecture,
                data_directories,
            },
        ))
    }

    pub fn get_import_table_entry(&self) -> Option<DataDirectory> {
        if self.data_directories.len() >= 2 {
            Some(self.data_directories[1])
        } else {
            None
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn optional_header() {
        // x86
        let data = vec![
            0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01,
            0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        ];

        assert_eq!(
            OptionalHeader::parse(&data).unwrap().1,
            OptionalHeader {
                architecture: Architecture::X86,
                data_directories: vec![
                    DataDirectory {
                        rva: 0x03020100,
                        size: 0x07060504
                    },
                    DataDirectory {
                        rva: 0x0b0a0908,
                        size: 0x0f0e0d0c
                    },
                ]
            }
        );

        // x64
        let data = vec![
            0x0b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ];

        assert_eq!(
            OptionalHeader::parse(&data).unwrap().1,
            OptionalHeader {
                architecture: Architecture::X64,
                data_directories: vec![
                    DataDirectory {
                        rva: 0x03020100,
                        size: 0x07060504
                    },
                    DataDirectory {
                        rva: 0x0b0a0908,
                        size: 0x0f0e0d0c
                    },
                ]
            }
        );
    }
}
